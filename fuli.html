<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>iOS 风格滚轮（快速惯性+阻尼+收窄横条）</title>
<style>
html, body { margin:0; height:100%; overflow:hidden; background:#111; font-family:sans-serif; display:flex; justify-content:center; align-items:center;}
.picker-container { position:relative; height:400px; width:140px; overflow:hidden; touch-action:none; perspective: 800px; }
.picker-list { position:absolute; top:0; left:0; right:0; transform-style: preserve-3d; }
.picker-item { height:70px; display:flex; justify-content:center; align-items:center; font-size:28px; color:#aaa; transition: all 0.1s; }
.selected-bar { 
  position:absolute; 
  top:50%; 
  transform:translateY(-50%); 
  left:0; 
  right:0; 
  height:49px; /* 收窄 30% */
  background: rgba(30,144,255,0.2); 
  pointer-events:none; 
  border-radius:8px; 
  z-index:10;
}
.spacer { height:200px; }
.mask-top, .mask-bottom { position:absolute; left:0; width:100%; height:100px; z-index:5; pointer-events:none;}
.mask-top { top:0; background: linear-gradient(to bottom, #111 0%, transparent 100%);}
.mask-bottom { bottom:0; background: linear-gradient(to top, #111 0%, transparent 100%);}
</style>
</head>
<body>
<div class="picker-container" id="picker">
  <div class="picker-list" id="pickerList"></div>
  <div class="selected-bar"></div>
  <div class="mask-top"></div>
  <div class="mask-bottom"></div>
</div>

<script>
(function(){
const picker = document.getElementById('picker');
const list = document.getElementById('pickerList');
const itemHeight = 70;
const min = 0.5, max = 50, step = 0.5;
const values = [];
for(let v=min; v<=max; v+=step) values.push(v.toFixed(1));

list.innerHTML = '<div class="spacer"></div>' + values.map(v=>`<div class="picker-item">${v}</div>`).join('') + '<div class="spacer"></div>';
const items = list.querySelectorAll('.picker-item');

const spacerHeight = 200;
let offset = picker.clientHeight/2 - itemHeight/2 - spacerHeight;
let startY = 0;
let velocity = 0;
let animFrame;
let lastTime = performance.now();
let isSnapping = false;
let targetOffset = 0;

const decelerationRate = 0.998; // iOS-like deceleration rate per ms
const maxVel = 10000; // High limit for fast scrolling (px/s)
const snapK = 10000; // Spring constant for snap
const snapD = 3 * Math.sqrt(snapK); // Over-damped for clean snap without oscillation
const boundaryK = 1000; // Spring constant for boundaries

function updateHighlight() {
    const center = picker.clientHeight/2;
    let closestItem = null, closestDist = Infinity;
    items.forEach(item => {
        const itemCenter = item.offsetTop + itemHeight/2 + offset;
        const dist = Math.abs(center - itemCenter);
        const scale = Math.max(0.7, 1 - dist/200);
        const rotateX = Math.max(-40, Math.min(40, (center-itemCenter)/5));
        const colorVal = Math.round(Math.max(170, 255-dist/2));
        item.style.transform = `scale(${scale}) rotateX(${rotateX}deg)`;
        if(dist < closestDist){
            closestDist = dist;
            closestItem = item;
        }
        item.style.color = `rgb(${colorVal},${colorVal},${colorVal})`;
        item.style.fontWeight = "normal";
    });
    if(closestItem){
        closestItem.style.color = "#1e90ff";
        closestItem.style.fontWeight = "bold";
    }
}

function render() { 
    list.style.transform = `translateY(${offset}px)`; 
    updateHighlight(); 
}

function spring(o) {
    const maxOffset = picker.clientHeight/2 - itemHeight/2;
    const minOffset = -(itemHeight*(values.length-1)) + picker.clientHeight/2 - itemHeight/2 - spacerHeight;
    if(o > maxOffset) return (o - maxOffset) * boundaryK;
    if(o < minOffset) return (o - minOffset) * boundaryK;
    return 0;
}

function animate(timestamp) {
    if (lastTime === 0) lastTime = timestamp;
    const dt = Math.min((timestamp - lastTime) / 1000, 0.05); // Cap dt to avoid jumps
    lastTime = timestamp;

    let accel = -spring(offset); // Boundary spring force (pulls back)

    if (isSnapping) {
        const diff = targetOffset - offset;
        accel += snapK * diff - snapD * velocity; // Snap spring and damping
    } else {
        // Free scrolling with iOS-like exponential deceleration
        velocity *= Math.pow(decelerationRate, dt * 1000);
    }

    velocity += accel * dt;
    offset += velocity * dt;

    // Cap velocity
    if (velocity > maxVel) velocity = maxVel;
    if (velocity < -maxVel) velocity = -maxVel;

    render();

    // Check if should start snapping
    if (!isSnapping && Math.abs(velocity) < 50 && Math.abs(spring(offset)) < 50) {
        isSnapping = true;
        const center = picker.clientHeight/2 - itemHeight/2 - spacerHeight;
        const index = Math.round(-offset / itemHeight);
        targetOffset = -index * itemHeight + center;
    }

    // Check if snapping is complete
    if (isSnapping && Math.abs(targetOffset - offset) < 1 && Math.abs(velocity) < 10) {
        offset = targetOffset;
        velocity = 0;
        isSnapping = false;
        render();
        cancelAnimationFrame(animFrame);
    } else {
        animFrame = requestAnimationFrame(animate);
    }
}

// Touch events
picker.addEventListener('touchstart', e => {
    cancelAnimationFrame(animFrame);
    isSnapping = false;
    startY = e.touches[0].clientY;
    velocity = 0;
    lastTime = performance.now();
}, {passive: true});

picker.addEventListener('touchmove', e => {
    const now = performance.now();
    const dt = (now - lastTime) / 1000 || 0.016;
    lastTime = now;
    const y = e.touches[0].clientY;
    const delta = y - startY;
    startY = y;
    velocity = (delta / dt) * 2; // Boost sensitivity for faster response (px/s)
    offset += delta;
    render();
}, {passive: true});

picker.addEventListener('touchend', () => {
    animFrame = requestAnimationFrame(animate);
});

render();
})();
</script>
</body>
</html>
