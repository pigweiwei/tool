<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>iOS 风格滚轮（快速惯性+阻尼+收窄横条）</title>
<style>
html, body { margin:0; height:100%; overflow:hidden; background:#111; font-family:sans-serif; display:flex; justify-content:center; align-items:center;}
.picker-container { position:relative; height:400px; width:140px; overflow:hidden; touch-action:none; perspective: 800px; }
.picker-list { position:absolute; top:0; left:0; right:0; transform-style: preserve-3d; }
.picker-item { height:70px; display:flex; justify-content:center; align-items:center; font-size:28px; color:#aaa; transition: all 0.1s; }
.selected-bar { 
  position:absolute; 
  top:50%; 
  transform:translateY(-50%); 
  left:0; 
  right:0; 
  height:49px; /* 收窄 30% */
  background: rgba(30,144,255,0.2); 
  pointer-events:none; 
  border-radius:8px; 
  z-index:10;
}
.spacer { height:200px; }
.mask-top, .mask-bottom { position:absolute; left:0; width:100%; height:100px; z-index:5; pointer-events:none;}
.mask-top { top:0; background: linear-gradient(to bottom, #111 0%, transparent 100%);}
.mask-bottom { bottom:0; background: linear-gradient(to top, #111 0%, transparent 100%);}
</style>
</head>
<body>
<div class="picker-container" id="picker">
  <div class="picker-list" id="pickerList"></div>
  <div class="selected-bar"></div>
  <div class="mask-top"></div>
  <div class="mask-bottom"></div>
</div>

<script>
(function(){
const picker = document.getElementById('picker');
const list = document.getElementById('pickerList');
const itemHeight = 70;
const min = 0.5, max = 50, step = 0.5;
const values = [];
for(let v=min; v<=max; v+=step) values.push(v.toFixed(1));

list.innerHTML = '<div class="spacer"></div>' + values.map(v=>`<div class="picker-item">${v}</div>`).join('') + '<div class="spacer"></div>';
const items = list.querySelectorAll('.picker-item');

const spacerHeight = 200;
let offset = picker.clientHeight/2 - itemHeight/2 - spacerHeight;
let startY = 0;
let velocity = 0;
let animFrame;
let lastTime = 0;

function updateHighlight() {
    const center = picker.clientHeight/2;
    let closestItem = null, closestDist = Infinity;
    items.forEach(item => {
        const itemCenter = item.offsetTop + itemHeight/2 + offset;
        const dist = Math.abs(center - itemCenter);
        const scale = Math.max(0.7, 1 - dist/200);
        const rotateX = Math.max(-40, Math.min(40, (center-itemCenter)/5));
        const colorVal = Math.round(Math.max(170, 255-dist/2));
        item.style.transform = `scale(${scale}) rotateX(${rotateX}deg)`;
        if(dist < closestDist){
            closestDist = dist;
            closestItem = item;
        }
        item.style.color = `rgb(${colorVal},${colorVal},${colorVal})`;
        item.style.fontWeight = "normal";
    });
    if(closestItem){
        closestItem.style.color = "#1e90ff";
        closestItem.style.fontWeight = "bold";
    }
}

function render() { 
    list.style.transform = `translateY(${offset}px)`; 
    updateHighlight(); 
}

function spring(o) {
    const maxOffset = picker.clientHeight/2 - itemHeight/2;
    const minOffset = -(itemHeight*(values.length-1)) + picker.clientHeight/2 - itemHeight/2 - spacerHeight;
    if(o > maxOffset) return (o - maxOffset)*0.5; // 进一步增强边界弹簧力
    if(o < minOffset) return (o - minOffset)*0.5;
    return 0;
}

// 进一步改进的 animate 函数
function animate() {
    const springForce = spring(offset);
    const speed = Math.abs(velocity);

    // 增强非线性阻尼：低速更强阻尼，高速更平滑衰减
    let damping = speed < 5 ? 0.97 : 0.90 * Math.exp(-speed / 150); // 调整参数以增强惯性和阻尼感
    velocity *= damping;

    // 增强重力阻力，提供更强的“重量感”
    const gravity = 0.15; // 增加重力值
    velocity -= Math.sign(velocity) * gravity;

    offset += velocity - springForce;

    // 进一步提高速度上限，增强快速滚动的惯性
    const maxVel = 800; // 从 600 提高到 800
    if(velocity > maxVel) velocity = maxVel;
    if(velocity < -maxVel) velocity = -maxVel;

    render();

    // 优化吸附逻辑：增加容忍度，避免后退抖动
    if(Math.abs(velocity) < 1.0 && Math.abs(springForce) < 0.8) { // 放宽触发条件
        let index = Math.round((-offset + picker.clientHeight/2 - itemHeight/2 - spacerHeight)/itemHeight);
        const targetOffset = -index*itemHeight + picker.clientHeight/2 - itemHeight/2 - spacerHeight;
        
        // 改进弹簧-阻尼系统：增强阻尼以减少过冲和后退
        const diff = targetOffset - offset;
        const k = 0.3; // 增加弹簧刚度，加速吸附
        const d = 0.92; // 增加阻尼系数，减少抖动
        const springAccel = diff * k;
        velocity += springAccel;
        velocity *= d;

        // 添加阈值判断：如果 diff 很小，直接 snap 到 target，避免无限后退
        if(Math.abs(diff) < 1.0 && Math.abs(velocity) < 0.5) {
            offset = targetOffset;
            velocity = 0;
            render();
            cancelAnimationFrame(animFrame);
        } else if(Math.abs(diff) > 0.5 || Math.abs(velocity) > 0.5) {
            animFrame = requestAnimationFrame(animate);
        } else {
            offset = targetOffset;
            velocity = 0;
            render();
            cancelAnimationFrame(animFrame);
        }
    } else {
        animFrame = requestAnimationFrame(animate);
    }
}

// 触摸事件
picker.addEventListener('touchstart', e=>{
    cancelAnimationFrame(animFrame);
    startY = e.touches[0].clientY;
    velocity = 0;
    lastTime = Date.now();
}, {passive:true});

picker.addEventListener('touchmove', e=>{
    const y = e.touches[0].clientY;
    const now = Date.now();
    const dt = now - lastTime || 16;
    lastTime = now;
    const delta = y - startY;
    startY = y;

    // 调整速度灵敏度，提供更自然的惯性起始
    velocity = delta / dt * 60; // 进一步降低到 60，增强重量感
    offset += delta;
    render();
}, {passive:true});

picker.addEventListener('touchend', ()=>{
    animFrame = requestAnimationFrame(animate);
});

render();
})();
</script>
</body>
</html>
