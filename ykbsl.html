<script>
// ====== ç«–æ¡é€»è¾‘ ======
const profitBar = document.getElementById('profitLoss');
const breakevenBar = document.getElementById('breakeven');
const profitValue = document.getElementById('profitLossValue');
const breakevenValue = document.getElementById('breakevenValue');

const maxProfitRatio = 10;
let profitLogical = 3;  
let breakevenLogical = 100/(1+profitLogical);

// ç»Ÿä¸€çš„æ•°å€¼æœ€ä½Žæ˜¾ç¤ºä½ç½®ï¼ˆç›ˆäºæ¯” 0.5 æ—¶çš„ä½ç½®ï¼‰
let minValueTop = null;

function calculateBreakeven(r) {
  if (r === Infinity) return 0;
  return 100 / (1 + r);
}

function animateBarHeight(bar, valueDisplay, targetVal, isPercent=false){
  const containerHeight = bar.parentElement.clientHeight - 50; 
  let minHeight = 5;
  let displayVal = targetVal;
  let heightVal = targetVal;

  if (targetVal === Infinity || targetVal > (isPercent ? 100 : maxProfitRatio)) {
    displayVal = 'ðŸ…‰';  // âœ… æ”¹è¿™é‡Œ
    heightVal = isPercent ? 100 : maxProfitRatio;
  } else if (targetVal < 0 || !isFinite(targetVal)) {
    displayVal = isPercent ? '0%' : '0.00';
    heightVal = 0;
  }

  let targetHeight = isPercent ? containerHeight * heightVal / 100 : containerHeight * heightVal / maxProfitRatio;
  if (targetHeight < minHeight) targetHeight = minHeight;

  bar.style.height = targetHeight + 'px';

  let valueTop = containerHeight - targetHeight - 20;

  // åˆå§‹åŒ– minValueTopï¼Œç”¨ç›ˆäºæ¯” 0.5 æ—¶çš„ä½ç½®
  if (!isPercent && minValueTop === null) {
    let tmpHeight = containerHeight * 0.5 / maxProfitRatio;
    minValueTop = containerHeight - tmpHeight - 20;
  }

  // é™åˆ¶æœ€å°ä½ç½®
  if (minValueTop !== null) {
    valueTop = Math.min(valueTop, minValueTop);
  }

  valueTop = Math.max(valueTop, 0);
  valueDisplay.style.top = valueTop + 'px';

  valueDisplay.textContent = (typeof displayVal === 'string') ? displayVal : 
    (isPercent ? Math.round(displayVal) + '%' : displayVal.toFixed(2));
}

function makeDraggable(wrapper, bar, valueDisplay, isPercent=false, callback=null){
  let dragging=false;
  let startValue = 0;
  let startX = 0;
  let startY = 0;
  let dragDirection = null; 
  const containerHeight = wrapper.clientHeight - 50;

  function startDrag(e){
    dragging = true;
    startX = e.touches ? e.touches[0].clientX : e.clientX;
    startY = e.touches ? e.touches[0].clientY : e.clientY;
    dragDirection = null;
    let currentText = valueDisplay.textContent;
    startValue = currentText === 'ðŸ…‰' ? (isPercent ? 100 : maxProfitRatio) : parseFloat(currentText);
    if (isNaN(startValue)) startValue = 0;
    e.preventDefault();
  }

  function endDrag(){
    if(!dragging) return;
    dragging = false;
    if (dragDirection === "vertical") {
      let currentText = valueDisplay.textContent;
      if (currentText === 'ðŸ…‰') {
        if (callback) callback(Infinity);
      } else {
        let currentValue = parseFloat(currentText);
        if (!isPercent) {
          if (currentValue >= maxProfitRatio) {
            currentValue = maxProfitRatio;
          }
          let snappedValue = Math.round(currentValue / 0.5) * 0.5;
          animateBarHeight(bar, valueDisplay, snappedValue, isPercent);
          if (callback) callback(snappedValue);
        }
      }
    }
  }

  function moveDrag(e){
    if(!dragging) return;
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    if (dragDirection === null) {
      let dx = clientX - startX;
      let dy = clientY - startY;
      dragDirection = Math.abs(dy) > Math.abs(dx) ? "vertical" : "horizontal";
    }
    if (dragDirection === "vertical") {
      let delta = startY - clientY; 
      let value;
      if (isPercent) {
        value = startValue + delta / containerHeight * 100;
        value = Math.min(Math.max(value, 0), 100);
      } else {
        value = startValue + delta / containerHeight * maxProfitRatio;
        value = Math.max(value, 0);
      }
      animateBarHeight(bar, valueDisplay, value, isPercent);
      if (callback) callback(value);
    }
  }

  wrapper.addEventListener('touchstart', startDrag);
  wrapper.addEventListener('mousedown', startDrag);
  document.addEventListener('touchend', endDrag);
  document.addEventListener('mouseup', endDrag);
  wrapper.addEventListener('touchmove', moveDrag, { passive: false });
  wrapper.addEventListener('mousemove', moveDrag);
}

// ç›ˆäºæ¯”
makeDraggable(document.getElementById('wrapperProfit'), profitBar, profitValue, false, r=>{
  profitLogical = r;
  breakevenLogical = calculateBreakeven(r);
  animateBarHeight(breakevenBar, breakevenValue, breakevenLogical, true);
});

// èƒœçŽ‡
makeDraggable(document.getElementById('wrapperBreakeven'), breakevenBar, breakevenValue, true, b=>{
  breakevenLogical = b;
  profitLogical = b > 0 ? (100 / b) - 1 : Infinity;
  animateBarHeight(profitBar, profitValue, profitLogical, false);
});

// åˆå§‹æ˜¾ç¤º
window.addEventListener('load', ()=>{
  animateBarHeight(profitBar, profitValue, profitLogical, false);
  animateBarHeight(breakevenBar, breakevenValue, breakevenLogical, true);
});

// ====== å³ä¾§å¯¼èˆªæ‰‹åŠ¿æ•´åˆ ======
const rightNav = document.getElementById('rightNav');
const overlay = document.getElementById('overlay');
const gestureRight = document.getElementById('gestureRight');

function openNav(){ 
  rightNav.classList.add('expanded'); 
  overlay.classList.add('show'); 
}
function closeNav(){ 
  rightNav.classList.remove('expanded'); 
  overlay.classList.remove('show'); 
}

// ç‚¹å‡»ç©ºç™½æ”¶å›ž
overlay.addEventListener('click', closeNav);

// å¯¼èˆªæ å†…éƒ¨ç©ºç™½ç‚¹å‡»æ”¶å›ž
rightNav.addEventListener('click', e=>{
  if(e.target.classList.contains('nav-item') || e.target.tagName === 'A') return;
  closeNav();
});

// å³å±å¹•è¾¹ç¼˜å‘å·¦æ»‘å±•å¼€
let startX=0;
gestureRight.addEventListener('touchstart', e=>{
  if(e.touches.length!==1) return;
  e.preventDefault();
  startX=e.touches[0].clientX;
});
gestureRight.addEventListener('touchmove', e=>{
  if(e.touches.length!==1) return;
  e.preventDefault();
});
gestureRight.addEventListener('touchend', e=>{
  const deltaX = startX - e.changedTouches[0].clientX;
  if(deltaX > 30) openNav();
  startX=0;
});

// å¯¼èˆªæ æœ¬èº«å‘å³æ»‘æ”¶å›ž
let navStartX=0;
rightNav.addEventListener('touchstart', e=>{
  if(e.touches.length!==1) return;
  navStartX = e.touches[0].clientX;
});
rightNav.addEventListener('touchmove', e=>{
  if(e.touches.length!==1) return;
  e.preventDefault();
});
rightNav.addEventListener('touchend', e=>{
  if(navStartX === 0) return;
  const deltaX = e.changedTouches[0].clientX - navStartX; // å·¦â†’å³ä¸ºæ­£
  if(deltaX > 30) closeNav();
  navStartX = 0;
});
</script>
