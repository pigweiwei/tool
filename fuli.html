<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>iOS 风格滚轮（快速惯性+阻尼+收窄横条）</title>
<style>
html, body { margin:0; height:100%; overflow:hidden; background:#111; font-family:sans-serif; display:flex; justify-content:center; align-items:center;}
.picker-container { position:relative; height:400px; width:140px; overflow:hidden; touch-action:none; perspective: 800px; }
.picker-list { position:absolute; top:0; left:0; right:0; transform-style: preserve-3d; }
.picker-item { height:70px; display:flex; justify-content:center; align-items:center; font-size:28px; color:#aaa; transition: all 0.1s; }
.selected-bar { 
  position:absolute; 
  top:50%; 
  transform:translateY(-50%); 
  left:0; 
  right:0; 
  height:49px; /* 收窄 30% */
  background: rgba(30,144,255,0.2); 
  pointer-events:none; 
  border-radius:8px; 
  z-index:10;
}
.spacer { height:200px; }
.mask-top, .mask-bottom { position:absolute; left:0; width:100%; height:100px; z-index:5; pointer-events:none;}
.mask-top { top:0; background: linear-gradient(to bottom, #111 0%, transparent 100%);}
.mask-bottom { bottom:0; background: linear-gradient(to top, #111 0%, transparent 100%);}
</style>
</head>
<body>
<div class="picker-container" id="picker">
  <div class="picker-list" id="pickerList"></div>
  <div class="selected-bar"></div>
  <div class="mask-top"></div>
  <div class="mask-bottom"></div>
</div>

<script>
(function(){
const picker = document.getElementById('picker');
const list = document.getElementById('pickerList');
const itemHeight = 70;
const min = 0.5, max = 50, step = 0.5;
const values = [];
for(let v=min; v<=max; v+=step) values.push(v.toFixed(1));

list.innerHTML = '<div class="spacer"></div>' + values.map(v=>`<div class="picker-item">${v}</div>`).join('') + '<div class="spacer"></div>';
const items = list.querySelectorAll('.picker-item');

// 修正初始偏移量：考虑spacer高度，使第一个选项中心对齐横条中心
const spacerHeight = 200; // spacer的高度
let offset = picker.clientHeight/2 - itemHeight/2 - spacerHeight;
let startY = 0;
let velocity = 0;
let animFrame;
let lastTime = 0;

function updateHighlight() {
    const center = picker.clientHeight/2;
    let closestItem=null,closestDist=Infinity;
    items.forEach(item => {
        const itemCenter = item.offsetTop + itemHeight/2 + offset;
        const dist = Math.abs(center - itemCenter);
        const scale = Math.max(0.7, 1 - dist/200);
        const rotateX = Math.max(-40, Math.min(40, (center-itemCenter)/5));
        const colorVal = Math.round(Math.max(170, 255-dist/2));
        item.style.transform = `scale(${scale}) rotateX(${rotateX}deg)`;
        if(dist<closestDist){
            closestDist = dist;
            closestItem = item;
        }
        item.style.color=`rgb(${colorVal},${colorVal},${colorVal})`;
        item.style.fontWeight="normal";
    });
    if(closestItem){
        closestItem.style.color="#1e90ff";
        closestItem.style.fontWeight="bold";
    }
}

function render() { 
    list.style.transform = `translateY(${offset}px)`; 
    updateHighlight(); 
}

function spring(o){
    const maxOffset = picker.clientHeight/2 - itemHeight/2;
    const minOffset = -(itemHeight*(values.length-1)) + picker.clientHeight/2 - itemHeight/2 - spacerHeight;
    if(o > maxOffset) return (o - maxOffset)*0.2;
    if(o < minOffset) return (o - minOffset)*0.2;
    return 0;
}

// 高级阻尼 + 可控快速惯性
function animate() {
    const springForce = spring(offset);

    const speed = Math.abs(velocity);
    let damping = speed < 5 ? 0.98 : (speed < 20 ? 0.92 : 0.88);
    velocity *= damping;

    offset += velocity - springForce;

    const maxVel = 120;
    if(velocity>maxVel) velocity=maxVel;
    if(velocity<-maxVel) velocity=-maxVel;

    render();

    // 判断是否需要吸附到最近刻度
    if(Math.abs(velocity) < 0.5 && Math.abs(springForce) < 0.5) {
        // 计算最近的刻度索引，考虑spacer
        let index = Math.round((-offset + picker.clientHeight/2 - itemHeight/2 - spacerHeight)/itemHeight);
        const targetOffset = -index*itemHeight + picker.clientHeight/2 - itemHeight/2 - spacerHeight;
        
        // 平滑吸附动画
        const diff = targetOffset - offset;
        if(Math.abs(diff) > 0.5) {
            offset += diff * 0.2; // ease-out 效果
            animFrame = requestAnimationFrame(animate);
        } else {
            offset = targetOffset;
            render();
        }
    } else {
        animFrame = requestAnimationFrame(animate);
    }
}

// ================== 触摸事件 ==================
picker.addEventListener('touchstart', e=>{
    cancelAnimationFrame(animFrame);
    startY = e.touches[0].clientY;
    velocity = 0;
    lastTime = Date.now();
}, {passive:true});

picker.addEventListener('touchmove', e=>{
    const y = e.touches[0].clientY;
    const now = Date.now();
    const dt = now - lastTime || 16;
    lastTime = now;
    const delta = y - startY;
    startY = y;

    velocity = delta / dt * 32;
    offset += delta;
    render();
}, {passive:true});

picker.addEventListener('touchend', ()=>{
    animFrame = requestAnimationFrame(animate);
});

render();
})();
</script>
</body>
</html>
